Захват параметра функции paramName :
1. Добавить в класс-итератор как служебное поле <num>__paramName

Выполняет роль закэшированного начального значения параметра, если функция-итератор вызывается в нескольких местах.
В классе-итераторе в IEnumerable<T>.GetEnumerator при создании возможно нового класса-итератора для другого потока:
	1.1. Захватить в поле нового класса-итератора paramName кэшированное значение self.<>num__paramName

В новом теле функции-итератора:
	1.1. Создаем класс-хелпер (собственно итератор)
	1.2. Захват <>num__paramName = paramName
	1.3. Возвращаем класс-хелпер

2. Добавить в класс-итератор как служебное поле paramName

Используется собственно как параметр функции-итератора.

3. Заменить в теле функции-итератора использование параметра функции paramName -> self.paramName,
  	 где self - класса-хелпера

-----------------


Захват поля класса fieldName

1. Добавить в класс-итератор как служебное поле <>num__self,
     где self - класс содержащий функцию-итератор

В классе-итераторе в IEnumerable<T>.GetEnumerator при создании возможно нового класса-итератора для другого потока:
	1.1. Захватить в поле нового класса-итератора значение self.<>num__self от исходного класса с функцией-итератором

В теле функции-итератора захватить self содержающего итератор класса
	1.1. Создаем класс-хелпер (собственно итератор)
	1.2. Захват <>num__self = self;
	1.3. Возвращаем класс-хелпер

2. Заменить в теле функции-итератора использования поля класса fieldName -> self.<>num__self.fieldName,
	где self - класса-хелпера

----------------

Захват локальной переменной localName

1. Добавить в класс-итератор как служебное поле <num>__localName

2. Заменить в теле функции-итератора использования локальной переменной localName -> self.<num>__localName,
	где self - класса-хелпера


----------------

Захват параметра/другой непонятной фигни из метода-родителя (для вложенных функций)
???

----------------

Захват вызовов другого метода/свойства класса с функцией-итератором

1. Вызывать через захваченный self этого класса


----------------
Захват глобальных переменных 
Без изменений

----------------
Захват в методе-расширении:
Как формальный параметр


------------------
обращение к this -> через захваченный, остальное не трогать

------------------
Глобальные/поля:
На этапе синтаксиса не можем выяснить, является ли имя полем класса-предка (наш, или из .NET сборки - откуда то там)
Поэтому не можем утверждать глобальное ли имя
Откладываем до семантики как yield_unkown_reference(name)

